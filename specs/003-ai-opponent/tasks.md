# 任務清單：AI 對手

**功能**: AI 對手
**日期**: 2025年10月21日

## 實作策略

此計畫將遵循以使用者故事為中心的增量交付模型。我們將從 MVP（最小可行產品）開始，即使用者故事 1，它負責建立模式選擇的基礎。隨後，我們將依序實作 AI 的核心邏輯和難度選擇，每個階段都是一個可獨立測試的功能增量。

**MVP 範圍**: 包含使用者故事 1 (US1) 的所有任務。完成後，使用者將能夠在 UI 上選擇「玩家對戰」或「玩家對電腦」模式，為後續 AI 功能奠定基礎。

---

## 第 1 階段：基礎 UI 設定

此階段的任務是在現有 HTML 中加入新功能所需的 UI 元素。

- [x] T001 [P] 在 `index.html` 中，於棋盤上方新增用於選擇遊戲模式（PvP vs PvE）的控制項（例如，單選按鈕）。
- [x] T002 [P] 在 `index.html` 中，新增用於選擇 AI 難度（簡單/困難）的控制項，預設隱藏。
- [x] T003 在 `style.css` 中為新增的模式和難度選擇控制項添加基本樣式，並確保難度選項預設為隱藏。

---

## 第 2 階段：重構與狀態管理

此階段專注於重構現有 JavaScript 程式碼，以支援多種遊戲模式和 AI 狀態。

- [x] T004 在 `script.js` 頂部新增用於儲存遊戲模式 (`gameMode`) 和 AI 難度 (`aiDifficulty`) 的狀態變數。
- [x] T005 重構 `restartGame` 函式 in `script.js`，使其在重置遊戲時不清空模式和難度選擇，而是根據當前選擇開始新遊戲。
- [x] T006 修改 `handleCellClick` 函式 in `script.js` 的進入條件，使其在 AI 回合時不接受玩家點擊。

---

## 第 3 階段：使用者故事 1 - 選擇遊戲模式 (P1)

**目標**: 在遊戲開始前，玩家可以選擇要進行「玩家對戰 (PvP)」還是「玩家對電腦 (PvE)」。

**獨立測試標準**:
- 載入頁面後，可以看到模式選擇 UI。
- 選擇「玩家對電腦」時，難度選擇 UI 應變為可見。
- 選擇「玩家對戰」時，難度選擇 UI 應保持隱藏。
- 遊戲能根據所選模式正確啟動。

### 任務

- [x] T007 [US1] 在 `script.js` 中為模式選擇控制項新增事件監聽器。
- [x] T008 [US1] 實作事件處理邏輯 in `script.js`，當模式改變時，更新 `gameMode` 狀態變數。
- [x] T009 [US1] 根據 `gameMode` 的值，在 `script.js` 中控制 AI 難度選擇 UI 的顯示或隱藏。
- [x] T010 [US1] 修改遊戲啟動邏輯 in `script.js`，確保在 `restartGame` 時能識別當前的遊戲模式。

---

## 第 4 階段：使用者故事 2 - 與 AI 進行遊戲 (P2)

**目標**: 在「玩家對電腦」模式中，玩家下完一步棋後，AI 會自動在棋盤上走出合理的一步。

**獨立測試標準**:
- 在 PvE 模式下，玩家（X）走一步後，AI（O）會在 2 秒內於一個有效的空格中下棋。
- AI 的走法符合預設的「簡單」難度（隨機）。
- 遊戲狀態（如輪到誰）能正確更新。

### 任務

- [x] T011 [US2] 在 `handleCellClick` 函式中 in `script.js`，新增邏輯：在玩家下棋後，如果模式為 'PvE' 且遊戲未結束，則觸發 AI 回合。
- [x] T012 [US2] 在 `script.js` 中建立 `makeAIMove` 函式，作為 AI 行動的入口點。
- [x] T013 [US2] 在 `makeAIMove` 中，使用 `setTimeout` 創造一個短暫的延遲，以模擬 AI "思考"。
- [x] T014 [US2] 在 `makeAIMove` 中，實作「簡單」AI 邏輯：找出所有可用空格，並隨機選擇一個 in `script.js`。
- [x] T015 [US2] AI 選擇位置後，程式化地呼叫現有的下棋和檢查遊戲結束的邏輯 in `script.js`。

---

## 第 5 階段：使用者故事 3 - 選擇 AI 難度 (P3)

**目標**: 玩家可以選擇 AI 的難度（簡單、困難）。

**獨立測試標準**:
- 在 PvE 模式下，選擇「困難」難度。
- 嘗試與 AI 對戰，驗證 AI 會阻擋玩家的致勝走法。
- 驗證 AI 會在有機會一步獲勝時抓住機會。
- 驗證在困難模式下，最佳結果為平手。

### 任務

- [x] T016 [US3] 在 `script.js` 中為難度選擇控制項新增事件監聽器，以更新 `aiDifficulty` 狀態變數。
- [x] T017 [US3] 在 `script.js` 中建立 `findBestMove` 函式，用於實作 Minimax 演算法。
- [x] T018 [US3] 在 `findBestMove` 中，實作 Minimax 核心遞迴邏輯，為每個可能的走法評分 in `script.js`。
- [x] T019 [US3] 在 `makeAIMove` 函式中新增邏輯 in `script.js`：如果 `aiDifficulty` 為 'Hard'，則呼叫 `findBestMove`；否則，執行隨機走法。
- [x] T020 [US3] 確保 Minimax 演算法能正確處理獲勝（+10）、失敗（-10）和平手（0）的評分。

---

## 第 6 階段：潤飾與最終化

此階段處理跨功能性的最終調整和文件更新。

- [x] T021 [P] 在 `style.css` 中微調新 UI 元素的佈局和外觀，使其與整體風格一致。
- [x] T022 [P] 更新 `README.md` 檔案，加入關於如何選擇遊戲模式和 AI 難度的說明。
- [ ] T023 進行完整的手動端對端測試，涵蓋 `quickstart.md` 中定義的所有 PvP 和 PvE 情境。

---

## 相依性圖

```
[UI Setup] -> [Refactor] -> [US1] -> [US2] -> [US3] -> [Polish]
```

- 每個階段都依賴於前一個階段的完成，形成清晰的開發路徑。
- `US1` (模式選擇) 是 `US2` (AI 行動) 的前提。
- `US2` (基礎 AI 行動) 是 `US3` (困難 AI 邏輯) 的前提。

## 平行執行範例

- **階段 1 (基礎 UI 設定)**:
  - `T001` 和 `T002` 可以在 `index.html` 中同時處理。`T003` 可以在 `T001` 和 `T002` 完成後獨立進行。
- **階段 6 (潤飾與最終化)**:
  - `T021` (CSS 調整) 和 `T022` (文件更新) 可以完全平行進行。
