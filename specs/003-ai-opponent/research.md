# 研究：AI 對手策略

**日期**: 2025年10月21日
**功能**: AI 對手
**作者**: GitHub Copilot

## 1. AI 難度實作策略

### 任務

研究如何在純 JavaScript 環境中，實作「簡單」和「困難」兩種井字遊戲 AI 難度。

### 發現

#### 簡單難度

最直接的方法是讓 AI 從所有可用的空格中隨機選擇一個。

-   **實作**:
    1.  找出所有目前為 `null` 的格子索引。
    2.  從這些索引中隨機選擇一個。
    3.  AI 在該位置下棋。

-   **優點**: 實作極為簡單，符合「簡單」的定義。
-   **缺點**: AI 行為完全不可預測，沒有任何策略性。

#### 困難難度

為了讓 AI「難以被擊敗」，需要一個能評估局勢並做出最佳選擇的演算法。**Minimax 演算法**是解決井字遊戲這類零和、完全資訊遊戲的經典標準。

-   **實作**:
    1.  Minimax 是一個遞迴函式，它會探索遊戲所有可能的未來走向。
    2.  它為每個可能的走法評分：
        -   AI 獲勝：+10
        -   對手獲勝：-10
        -   平手：0
    3.  AI 會選擇能導向最高分數的路徑，同時假設對手會選擇讓 AI 分數最低的路徑。
    4.  為了最佳化效能，可以結合 **Alpha-Beta 剪枝**來減少不必要的計算分支。

-   **優點**: 能保證 AI 做出理論上的最佳決策，達到「不可擊敗」的目標。
-   **缺點**: 相較於隨機策略，實作較為複雜。

### 決策

1.  **簡單難度**: **採用隨機選擇策略**。
2.  **困難難度**: **採用 Minimax 演算法**。

### 理由

-   **符合需求**: 這兩種策略完美對應了規格中對「簡單」和「困難」的定義。
-   **技術可行性**: Minimax 演算法雖然較複雜，但在 3x3 的井字遊戲中，其計算量對於現代瀏覽器的 JavaScript 引擎來說是微不足道的，完全不會有效能問題。
-   **可擴展性**: 雖然目前不需要，但 Minimax 的結構未來若要擴展（例如加入「中等」難度，可透過限制遞迴深度或在某些情況下隨機選擇），也相對容易。

### 考慮過的替代方案

-   **規則式 AI**: 建立一系列硬編碼的規則（例如：「如果能贏，就下那裡」、「如果對手快贏了，就擋住他」）。這種方法比隨機好，但比 Minimax 簡單。被拒絕的原因是，要寫出完美無瑕的規則集幾乎等同於重新實作 Minimax，且更容易出錯。Minimax 提供了一個更通用、更可靠的解決方案。
